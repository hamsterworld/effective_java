추상화수준에 맞는 예외를 던져라.

메서드가 저수준예외를 처리하지않고 바깥으로 전파해버릴때 문제가 보통발생한다.
이는 내부구현을 노출하고 상위단계 API 를 오염시킨다.
다음 릴리스에서 구현방식을 변경하고 던지는 예외가 변경되면 기존 클라이언트 프로그램이 깨질가능성이 있다.

eat(음식물 음식물){
    위장 위장 = new 위장();
    위장.위액분비();   => 과식Exception
    위장.위장운동(음식물); => 소화액부족Exception
    위장.십이지장으로음식물보내기(음식물); => 위염Exception
}

위처럼 저런 각각의 저수준 Exception 을 터트린다고생각해보자.

밥먹기(음식물 음식물) throw 과식Exception,소화액부족Exception,위염Exception{
    eat();
}

이렇게 해버리게되면

class 식탁{
    main(){
        Person person = new Person();
        try{
            person.밥먹기();
        } catch(과식Exception e1){
            person.소화제먹기();
        } catch(소화액부족Exception e2){
            person.컨디션회복();
        } catch(위염Exception e3){
            person.병원가기();
        }
    }
}

하면 여기서 과식Exception,소화액부족Exception,위염Exception 들을 알고 이렇게 코딩을 해줘야한다 => 내부구현을 알게된다.
그리고 만약에 여기서 그걸처리하게되면 나중에
위장관련 내부구현이 변경되어 Exception 이 변경되거나 그러면
내부구현에맞춰서 또 식탁을 바꿔줘야된다.
그렇지않으면 위장에대한 새로운버전이 릴리즈됫을때 그것을사용한 클라이언트프로그램은 전부다 깨지게된다.

그러면어떻게?
이것을 하위계층에서는 잡기가힘들고
그렇다고 상위계층으로 보낼때 이것들을 그대로 노출하기 그렇다면
고수준의예외를 사용해서 보내라.


밥먹기(음식물 음식물){
    try{
        eat();
    } catch(과식Exception e1){
        throw 소화불량Exception();
    } catch(소화액부족Exception e2){
        throw 소화불량Exception();
    } catch(위염Exception e3){
        throw 소화불량Exception();
    }
}

이것도그러면 사실상 eat 의 내부구현을 아는거니까 밥먹기매서드도

밥먹기(음식물 음식물) throw 소화불량Exception() {
    try{
        eat();
    } catch(소화불량Exception() e){
        throw 소화불량Exception();
    }
}

그리고 위에 소화불량 3종셋트는 이제
소화불량Exception 의 하위 레벨로 들어가게만들자.

class 식탁{
    main(){
        Person person = new Person();
        try{
            person.밥먹기();
        } catch(소화불량Exception() e){
            person.소화제먹기(); or log.info(e.getMessage());
        }
    }
}
이렇게되야되지않을까?
(개인적으로, 그래도 어차피 애초에 검사예외를 복구할수있는방법은 거이없다. 그냥 위장에서 비검사예외을 던지고 logging 하는게 더낫다고 생각한다.)



** 검사예외이므로 사실 잡아주거나 외부로 전파하기때문에
그것이 코드가 필요하고 코드로 쓰게된다.
그러므로 릴리즈해서 Exception 이 변경되거나그러면 클라이언트가 깨지므로, 상위계층으로 보내서 이런문제를 방지해야한다고 말하는것같다.

** 사실 비검사예외를 사용하면 클라이언트 코드가 깨지거나 그럴일이 없으므로 사실상 크게상관이없을듯?

** 예외변환은 그냥 저수준예외를 고수준예외에 담아서 보여준다는것
installException 이 발생 그 하위로 메모리부족이랑 파일이름찾기실패 이런예외가있다고했을때
메모리부족이 발생하면 installException 에 담아서 상위계층으로 보낸다. 그 해당추상화레벨에 맞게 보내준다. 내부구현을 모르게!

** 책에서 get 구현체 인 무슨 이상한 골격 class 로 명세에 맞춰서 exception 을 변경하여 보내는 예시도 설명해주고있는듯(?)하다.


결론)
Exception 또한 상위계층에 던질때 그에맞춰 추상화단계를 맞추어서 보내주자.
그렇지않으면 외부상위계층에서 그것을 처리하려고할테고
하위계층에서 내부구현이 변경된다면 외부상위계층이 그것을 처리하는 코드를 내부구현을 아는상태에서! 코드를짜야한다.
그러면 서로 묶이게되고 하위계층구현이 변경되면 그 상위계층 코드가 깨질수있다.

그러나 중요한것은
하위계층에서 Exception 을 터지지않게하거나 그전에 catch 로 잡아서 처리하거나
혹은!
그냥 예외가 발생한부분에서 logging 하는 방법도있다 => 개인적으로 그냥 이게제일나은듯.


개인적인 결론)
예외가 발생한 지점에서 exception 을 그냥 비검사예외를 던지고 logging 하는게제일낫다.
그러면 외부에서 그걸 억지로 코딩해서 클라이언트가 깨질일도없고 왜 문제의원인이 뭐고,어디서발생했는지 더 정확히 알수있기때문이다.

