과도한 동기화는 피해라.

동기화 매서드 혹은 동기화 블록안에
재정의가능한 매서드나 클라이언트가 넘겨준 함수객체(Function 같은것들)을 넘겨주어서는 안된다.

Test1 에서는 괜찮다.

Test2 에서는 동기화블록과 매서드에
넘겨준 함수객체로 인해
ConcurrentModificationException 이 발생한다.
이는 동기화블록과 매서드는 list 의 순회도중 list 가 수정되는것을 막지못하기때문이다.
과도한 동기화블록을 과하게 사용한것은 이처럼
예기치못한 예외를 터트릴수있다.

Test3 에서는 다른 쓰레드를 이용하여 remove 하고있는데
이는 교착상태를 발생시킬수있다.
똑같이 과도한 동기화블록의 사용은 이처럼 교착상태와 같은 예기치 못한 예외를 터트릴수있다.

해결책
1. 동기화블록에서 빼니기
2. OneCopyWriteArray 사용하기
등등 여러가지가있다.

결론적으로는
동기화블록,메서드를 사용할때는 재정의가능한매서드나 넘겨준 함수객체를 사용하면안된다.
이는 동기화블록과매서드를 과하게 사용하는 측면에 속한다.
!! 동기화 블록과 매서드는 최소화해서 사용하고 되도록이면 이런 가변공유데이터 사용을 줄이자!

성능적인 측면에서도
멀티코어 환경에서
같이 관리하는 필드,자원의 경우
서로간의 동기화로인해 통신을하게되고 이는 곧 많은 성능낭비이다.
이측면도 항상 생각하자.


++ long,double 은 thread-safe 하지않다!
    JVM 은 한번에 stream 을 읽어오는 byte 가 4byte 이다.
    그래서 long,double 이 공유가변데이터라면
    한쓰레드가 제대로 read,write 도 안될수있다.
    그러나 저거 외에 다른 원시타입들은
    4byte 로 보장되므로 한번에 read,write 가 가능하다.
    단, 쓰레드간의 데이터통신 이나 복잡한 연산에서의 원자성마저 보장해주지않는다!(매우 주의!)

++ volatile 은 visibility 를 보장한다 즉, 동기화측면에서 쓰레드간 통신의 기능을 사용하는것.
    그러나!
    long,double 과 같은 8byte 에서는 read,write 하는것에대한 원자성을 보장해준다.

++ 원자성이란?
    하나의 작업단위를 보장하는것
    하나의 작업단위라고 보는게 제일편할듯